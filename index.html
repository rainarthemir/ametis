<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Ametis Live Bus Map ‚Äî Focused View</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  html, body, #map { height: 100%; margin:0; padding:0; }

  /* üöç –ö—Ä—É–∂–æ–∫ –∞–≤—Ç–æ–±—É—Å–∞ */
  .bus-icon {
    border-radius: 50%;
    color: #fff;
    text-align: center;
    font-size: 12px;
    font-weight: bold;
    line-height: 26px;
    width: 26px; height: 26px;
    border: 2px solid #fff;
    display: inline-block;
    vertical-align: middle;
    box-sizing: border-box;
  }

  /* üî¥ –ê–∫—Ç–∏–≤–Ω–∞—è –º–∞—à–∏–Ω–∞ (–≤—ã–±—Ä–∞–Ω–Ω–∞—è) */
  .bus-icon.selected {
    border-color: red !important;
    box-shadow: 0 0 4px rgba(255,0,0,0.6);
  }

  /* ‚Ü™Ô∏è –¢–∞–±–ª–∏—á–∫–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
  .bus-dir {
    display: inline-block;
    vertical-align: middle;
    background: white;
    color: #222;
    border-radius: 4px;
    border: 1px solid #ddd;
    padding: 1px 6px;
    font-size: 11px;
    font-weight: 500;
    margin-left: 4px;
    white-space: nowrap;
  }

  .bus-icon-wrap {
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1001; /* –≤—ã—à–µ –≤—Å–µ–≥–æ –æ—Å—Ç–∞–ª—å–Ω–æ–≥–æ */
    position: relative;
  }

  /* üöè –ü–æ–¥–ø–∏—Å–∏ –æ—Å—Ç–∞–Ω–æ–≤–æ–∫ */
  .stop-label {
    background: transparent;
    border: none;
    font-size: 10px;
    color: #333;
    text-shadow: 0 0 3px white;
    white-space: nowrap;
    transform: translateX(10px); /* üëâ –°–¥–≤–∏–≥ –≤–ø—Ä–∞–≤–æ */
  }

  /* üîò –ö–Ω–æ–ø–∫–∞ "–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å—ë" */
  #resetViewBtn {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background: white;
    color: #333;
    border: 2px solid #555;
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    transition: all 0.2s ease;
    z-index: 2000;
  }
  #resetViewBtn:hover {
    background: #333;
    color: white;
    transform: scale(1.05);
  }
</style>
</head>
<body>
<div id="map"></div>
<button id="resetViewBtn" title="–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –º–∞—Ä—à—Ä—É—Ç—ã">Afficher tout</button>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/protobufjs@7.3.2/dist/protobuf.min.js"></script>
<script>
const map = L.map('map').setView([49.894, 2.295], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);

let FeedMessage;
let markers = [];
let allVehicles = [];
let currentShapeLayer = null;
let stopLayer = L.layerGroup().addTo(map);
let stopBlinkTimers = [];
let currentRouteId = null;
let currentTripId = null;
let lastTripUpdates = {};

const stops = {};
const trips = {};
const shapes = {};
const routeColors = {};
const stopTimes = {};
let stopTimesIndexed = false;

/* ===== –£—Ç–∏–ª–∏—Ç—ã ===== */
async function loadCsv(path) {
  const res = await fetch(path);
  const text = await res.text();
  const [header, ...rows] = text.trim().split(/\r?\n/);
  const headers = header.split(",");
  return rows.map(line => {
    const cols = line.split(",");
    const o = {};
    headers.forEach((h,i)=>o[h]=cols[i]);
    return o;
  });
}
function nowMs() { return Date.now(); }
function normalizeShort(name) {
  if (!name) return "";
  return String(name).toLowerCase().trim().replace(/[^a-z0-9]/g,"");
}
function clearStopLayer() {
  stopBlinkTimers.forEach(id => clearInterval(id));
  stopBlinkTimers = [];
  stopLayer.clearLayers();
}

/* ===== –ó–∞–≥—Ä—É–∑–∫–∞ GTFS ===== */
async function loadStaticData() {
  const [stopsList, routes, tripsList, shapesList, stopTimesList] = await Promise.all([
    loadCsv("gtfs/stops.txt"),
    loadCsv("gtfs2/routes.txt"),
    loadCsv("gtfs/trips.txt"),
    loadCsv("gtfs/shapes.txt"),
    loadCsv("gtfs/stop_times.txt")
  ]);

  stopsList.forEach(s=>{
    stops[s.stop_id] = { name:s.stop_name, lat:+s.stop_lat, lon:+s.stop_lon };
  });

  routes.forEach(r=>{
    const key = normalizeShort(r.route_short_name || r.route_id);
    routeColors[key] = "#" + (r.route_color?.padStart(6,"0") || "000000");
  });

  tripsList.forEach(t=>{
    trips[t.trip_id] = { route_id:t.route_id, headsign:t.trip_headsign, shape_id:t.shape_id };
  });

  shapesList.forEach(s=>{
    if (!shapes[s.shape_id]) shapes[s.shape_id] = [];
    shapes[s.shape_id].push([+s.shape_pt_lat, +s.shape_pt_lon, +s.shape_pt_sequence]);
  });
  for (const id in shapes) shapes[id].sort((a,b)=>a[2]-b[2]);

  stopTimesList.forEach(st=>{
    if (!stopTimes[st.trip_id]) stopTimes[st.trip_id] = [];
    stopTimes[st.trip_id].push({ stop_id: st.stop_id, seq: +st.stop_sequence });
  });
  for (const t in stopTimes) stopTimes[t].sort((a,b)=>a.seq - b.seq);
  stopTimesIndexed = true;
}

/* ===== –ü—Ä–æ—Ç–æ ===== */
async function initProto() {
  const root = await protobuf.load("gtfs-realtime.proto");
  FeedMessage = root.lookupType("transit_realtime.FeedMessage");
}
async function fetchFeed(url) {
  const res = await fetch(url);
  if (!res.ok) throw new Error("HTTP "+res.status);
  const buf = await res.arrayBuffer();
  return FeedMessage.decode(new Uint8Array(buf));
}

/* ===== –û—Å—Ç–∞–Ω–æ–≤–∫–∏ ===== */
function drawTripStops(tripId, nextStopId) {
  if (!stopTimesIndexed) return;
  const list = stopTimes[tripId];
  if (!list || !list.length) return;
  clearStopLayer();
  const nextIdx = nextStopId ? list.findIndex(s => s.stop_id === nextStopId) : -1;

  list.forEach((s, idx) => {
    const st = stops[s.stop_id];
    if (!st) return;
    let fill = "white";
    if (nextIdx >= 0) {
      if (idx < nextIdx) fill = "#ccc";
      else if (idx === nextIdx) fill = "yellow";
      else fill = "white";
    }
    const circle = L.circleMarker([st.lat, st.lon], {
      radius: 6.5, color: "black", weight: 1,
      fillColor: fill, fillOpacity: 1
    }).addTo(stopLayer);
    L.marker([st.lat, st.lon], {
      icon: L.divIcon({ className: "stop-label", html: st.name, iconSize: null })
    }).addTo(stopLayer);
    if (idx === nextIdx) {
      let isYellow = true;
      const timer = setInterval(()=>{
        isYellow = !isYellow;
        circle.setStyle({ fillColor: isYellow ? "yellow" : "white" });
      }, 700);
      stopBlinkTimers.push(timer);
    }
  });
}

/* ===== –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç ===== */
async function loadVehicles() {
  try {
    const [posFeed, tripFeed] = await Promise.all([
      fetchFeed("https://proxy.transport.data.gouv.fr/resource/ametis-amiens-gtfs-rt-vehicle-position"),
      fetchFeed("https://proxy.transport.data.gouv.fr/resource/ametis-amiens-gtfs-rt-trip-update")
    ]);

    const tripUpdates = {};
    tripFeed.entity.forEach(e=>{
      const tid = e.tripUpdate?.trip?.tripId;
      if (tid) tripUpdates[tid] = e.tripUpdate;
    });
    lastTripUpdates = tripUpdates;

    allVehicles = posFeed.entity.filter(e=>e.vehicle && e.vehicle.position);
    updateVisibleVehicles(tripUpdates);

  } catch(err) {
    console.error("–û—à–∏–±–∫–∞ RT:", err);
  }
}

/* ===== –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º—ã—Ö –º–∞—à–∏–Ω ===== */
function updateVisibleVehicles(tripUpdates = lastTripUpdates) {
  markers.forEach(m=>map.removeLayer(m));
  markers = [];

  const filtered = currentRouteId
    ? allVehicles.filter(e=>{
        const t = trips[e.vehicle.trip?.tripId];
        return t && t.route_id === currentRouteId;
      })
    : allVehicles;

  filtered.forEach(e=>{
    const v = e.vehicle;
    const tripId = v.trip?.tripId;
    const t = trips[tripId];
    if (!t) return;

    const color = routeColors[normalizeShort(t.route_id)] || "#666";
    const shortName = t.route_id.toUpperCase();
    const headsign = t.headsign || "";

    let nextStopId = null, nextStopName = "‚Äî";
    const tu = tripUpdates[tripId];
    if (tu?.stopTimeUpdate?.length) {
      const next = tu.stopTimeUpdate.find(s=>s.arrival?.time*1000 > nowMs()) || tu.stopTimeUpdate[0];
      if (next) {
        nextStopId = next.stopId;
        nextStopName = stops[next.stopId]?.name || next.stopId;
      }
    }

    const isSelected = tripId === currentTripId;
    const showDir = !!currentRouteId;

    const iconHtml = `
      <div class="bus-icon-wrap">
        <div class="bus-icon ${isSelected ? 'selected' : ''}" style="background:${color}">${shortName}</div>
        ${showDir && headsign ? `<div class="bus-dir">${headsign}</div>` : ""}
      </div>`;
    const icon = L.divIcon({ html: iconHtml, className:'', iconSize:null });

    const marker = L.marker([v.position.latitude, v.position.longitude], { icon, zIndexOffset: 1000 })
      .addTo(map)
      .bindPopup(`<b>${shortName}</b><br>${headsign}<br>–°–ª–µ–¥. –æ—Å—Ç–∞–Ω–æ–≤–∫–∞: ${nextStopName}`, {
        autoClose:false,
        closeOnClick:false
      });

    marker.on("click", ()=>{
      currentRouteId = t.route_id;
      currentTripId = tripId;

      if (currentShapeLayer) map.removeLayer(currentShapeLayer);
      clearStopLayer();

      if (t.shape_id && shapes[t.shape_id]) {
        const pts = shapes[t.shape_id].map(p=>[p[0],p[1]]);
        currentShapeLayer = L.polyline(pts, { color, weight:4 }).addTo(map);
        map.fitBounds(currentShapeLayer.getBounds());
      }
      if (nextStopId) drawTripStops(tripId, nextStopId);
      updateVisibleVehicles(tripUpdates);
      marker.openPopup();
    });

    markers.push(marker);
  });
}

/* ===== –ö–Ω–æ–ø–∫–∞ "–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å—ë" ===== */
document.getElementById("resetViewBtn").addEventListener("click", ()=>{
  currentRouteId = null;
  currentTripId = null;
  if (currentShapeLayer) {
    map.removeLayer(currentShapeLayer);
    currentShapeLayer = null;
  }
  clearStopLayer();
  updateVisibleVehicles(lastTripUpdates);
});

/* ===== –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ===== */
(async ()=>{
  await initProto();
  await loadStaticData();
  await loadVehicles();
  setInterval(loadVehicles, 2000);
})();
</script>
</body>
</html>

